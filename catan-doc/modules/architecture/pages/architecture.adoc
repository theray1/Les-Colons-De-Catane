:project: Les colons de Catane
= Architecture

== Introduction

[NOTE]
====
Le but de ce chapitre est de spécifier l'architecture d'une famille de produits,
dont le projet {project} en fait partie.

Il s'agit ici de choix génériques, qui peuvent s'appliquer à plusieurs projets.
====

== Vue physique

[NOTE]
====
La vue physique a pour but de décrire comment devrait être déployé le logiciel selon des nœuds logiques.
Ainsi que de définir comment ou plutôt par quel moyen les différents nœuds vont communiquer entre eux.
Et enfin le dernier but de cette vue est de donner les différentes contraintes de déploiement,
comme quelles librairies sont utilisées, quels sont les besoins matériels.
====

[NOTE]
====
Pour décrire la vue physique, vous allez vous appuyer sur deux diagrammes{nbsp}:

. Le diagramme de déploiement, qui ci doit expliquer la plupart des points énoncés précédemment.
. Le diagramme de déploiement au niveau des instances, qui respecte les spécifications du diagramme précédent,
pour montrer comment seront réparties les instances de ceci.
====

.Exemple d'un diagramme de déploiement (niveau spécification)
[plantuml]
----
include::deployment.adoc[]
----

[NOTE]
====
Décrivez les nœuds logiques, ainsi que les artefacts qui peuvent être déployés sur ces nœuds.
Vous pouvez profiter de ce diagramme pour expliquer le protocole de communication entre les nœuds.
====

.Exemple d'un diagramme de déploiement (niveau instance)
[plantuml]
----
include::deploymentInstance.adoc[]
----

[NOTE]
====
Expliquez ce diagramme, si les artefacts déployés sont différents, vous pouvez le montrer.
====

== Vue de la fiabilité

[NOTE]
====
Dans cette partie, vous allez présenter les différents choix architecturaux pour assurer la fiabilité du système.

Vous devez aussi présenter les prévisions de fonctionnement dans des conditions limite{nbsp}:
* Comment le système est initialisé{nbsp}?
* Comment le système est arrêté{nbsp}?
* Comment sont gérés les failles et le redémarrage du système{nbsp}?
====

[TIP]
====
Utilisez des diagrammes d'activité UML pour décrire l'initialisation et l'arrêt du système.
====

.Initialisation du système
[plantuml]
----
include::example$ad-initialization.plantuml[]
----

== Vue du développement

[NOTE]
====
Décrivez ici l'organisation du code source.
Plutôt que décrire les paquetages Java ou Typescript, décrivez plutôt les artefacts Maven et les modules Node.js.
====


[TIP]
====
Utilisez un https://www.uml-diagrams.org/package-diagrams-overview.html[Diagramme de paquetages]
pour décrire l'organisation du code source.
====

.Organisation des modules
[plantuml]
----
include::example$pd-example.plantuml[]
----




== Vue logique

[NOTE]
====
L'objectif de la vue logique est de décrire les différents composants qui jouent un rôle commun
dans les différents projets qui respectent une même architecture.
====


== Vue des processus

[plantuml]
....
@startuml
package ProcessusServer{
	package ThreadSpring{
		JavaSpring : Ecoute des sockets ...
	}
	
	package ThreadPrincipal{
		serverMain : GameManager
	}
	
	package ThreadN{
		GameControlerN : La n-ième Game.
	}
}
@enduml
....


== Vue technique : traduction de UML en code source

Nous allons simplement nous répartir le travail pour que chacun code une partie du projet.
L'idéal serait que tout le monde "touche à tout" et donc il serait interessent de ne pas distribuer simplement chaque classe à chaqu'un.



=== Règles de traduction des types de base

.Traduction des types de base
|===
| UML | Java | TypeScript

| Integer
| int
| number

| Boolean
| bool
| boolean

| String
| String
| string

| Real
| double
| number

|===

D'après : https://www.typescriptlang.org/docs/handbook/basic-types.html

=== Conventions de codage

Ce projet respecte les conventions JAVA distribuées par Oracle. Cela nous permet d'affirmer que notre code est "propre" selon les normes java présentes à cette adresse : https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html.

=== Règles de traduction des composants

Du côté serveur, on se retrouver avec 2 composants dont un qui ne sera pas codé qui est JavaSpring.
Le composant principal que nous nommons Server est l'ensemble des GameManager, GameControler, GameFacade... 

Du côté client, on va également se retrouver avec 2 composants dont un qui ne sera aussi pas codé et qui gère les webSockets, il n'a pas de nom.
On va devoir également codé le composant principal que nous nommons, incroyable nom, Client qui regroupe l'ensemble des GameManager, GameControler, GameFacade...

=== Règles de traduction des classes

Nous allons interpreter les diagrames UML tout simplements avec un package donne un package, une classe donne une classe...
Chaque classe utilisera une référence à une interface et non une classe pour minimiser le couplage.
[plantuml]
....
@startuml
package test{
	interface Test{}
	class TestImpl extends Test{}
}
@enduml
....

Ainsi, on va se retrouver avec un manager, ce dernier permet coté serveur de gérer l'ensemble des parties et de faire le lien entre ces dernières et Java Spring, et du coté client de faire le lien entre la librairie de websocket et la partie.
Pour la partie, c'est le contrôler qui va gérer cela, faire le lien entre le NetworkControler, la GameFacade et la CommandFactory.

* NetworkControler : Le contrôler qui s'occupe de la partie réseau, avec ce dernier, aucune commande/ressource du GameControler ne sort.
* GameFacade : Du designPattern Facade, cette classe permet de faire le lien entre le GameControler et le package du jeu. Cela permet de minimiser le couplage.
* CommandFactory : Du designPattern Factory, cette classe permet de fabriquer les Commands (cf Conception). 

=== Règles de traduction des associations

Les associations entre les classes / interfaces, sont assez simple : 

[plantuml]
....
@startuml
interface Test{}
class Test2 {}
note top : Test2 is composed of 1 Test

Test2 *-- Test

interface Test3{}
class Test4 {}
note top : Test4 is composed of 3-4 Test3

Test4 *-- "3-4" Test3
@enduml
....
Ainsi lorsqu'il n'y a pas de cardinalité, c'est qu'il y a une association de 1 pour 1.
Quoi qu'il arrive, dans notre serveur, il n'y aura qu'un seul GameManager et autant de GameControler qu'il n'y a de partie.

== Conclusion

Ceci est une conclusion hative; bien qu'elle existe, elle ne doit pas être utilisée dans un quelconque but de productivité ou de compréhension de ce projet. Nous remercions tous nos proches d'avoir pu contribuer de près ou de loin à ce fabuleux et merveilleux projet. :) Voilà merci à toutes et à tous. Bisouuuuuh UwU. 