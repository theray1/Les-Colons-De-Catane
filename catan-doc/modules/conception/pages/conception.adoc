= Conception détaillée

== Travail à réaliser

// ainsi que de décrire comment vous répondez aux différentes exigences non-fonctionnelles.

Objectif::
Spécification détaillée des composants: leur structure (diagramme de classes de conception), ainsi que le comportement de chaque opération fournie par le composants. Le comportement peut-être décrit en utilisant les diagrammes d'activité, d'interaction, les machines d'état, ainsi que OCL.

Moyens::
Appliquez les concepts vus en cours: design patterns, principes GRASP, bonnes pratiques, etc.




== Réponses aux exigences non-fonctionnelles

[NOTE]
====
Expliquez dans cette section les répondes aux différentes exigences non-fonctionnelles spécifiées.
====

=== Concurrence

NOTE: TODO!

=== Performance

NOTE: TODO!

=== Interopérabilité

NOTE: TODO!


=== Portabilité

Pour l'instant, le jeu est uniquement disponible sur navigateur.

=== Sécurité

Pour l'instant il n'y a pas vraiment de sécurité au niveau de la connexion. Quant au serveur, lui, s'il reçoit des commandes d'un autre joueur alors que ce n'est pas son tour, la commande est annulé, de même quand la commande est impossible (proposition de ressources non valide ...). 

==== Exigence de sécurité

Notre système doit être sécurisé, même si nous ne manipulons pas des données sensibles. Pour cela nous devons vérifier l'identité de l'utilisateur.


N'ayant pas à nous occuper de l'authentification de l'utilisateur nous admettons que le système s'occupant de cela est correct et lui-même sécurisé. Nous admettons également que, quelle que soit la plateforme utilisée (web, logiciel, application) le service d'authentification sera le même pour tous.


==== Maintenabilité

NOTE: TODO!

=== Interface utilisateur

NOTE: TODO!

=== Interface logicielle

NOTE: TODO!

=== Interface ou protocoles de communication

NOTE: TODO!

=== Correction

NOTE: TODO!

== Patrons logiciels utilisés

NOTE: Décrivez dans cette partie les patrons logiciels utilisés pour mettre en œuvre l'application.


=== Patron de conception Commandes

Nous utilisons le patron Commandes qui permet à au client et au serveur d'avoir un objet de communication.
Ainsi le client (le joueur), lorsque c'est à lui de jouer peut émettre des commandes et ainsi communiquer avec le serveur.
Chaque commande a une implémentation (un comportement précis) et cela permet au server de savoir quoi faire.

=== Patron de conception Factory

Nous utilisons le patron Factory qui permet au client et au server d'avoir un créateur d'instance de commande.

=== Patron de conception Facade

Ce design pattern va nous permettre d'avoir une classe qui fait le lien entre le serveur et le package qui implémente le jeu.
Cela va permettre dans une version future, de pouvoir changer l'implémentation du jeu sans changer le serveur.

=== Patron de conception Builder

Le Builder va nous permettre d'avoir une classe qui permet d'instancier les commandes (cf: Design pattern Commandes).
Avec ce builder, nous allons pouvoir fabriquer nos commandes sans que le serveur ait à connaitre les commandes.

=== Patron de conception Bridge

NOTE: TODO!

=== Patron de conception Mediator

NOTE: TODO!


=== Patron architectural "B"

NOTE: TODO!

== Choix techniques - Distribution des processus

[NOTE]
====
Explicitez les différents choix techniques et les réponses technologiques aux différentes contraintes que le système implique.
====

Pour cela nous allons donc vous présenter l'environnement général de développement puis énoncer les 4 contraintes que nous avons déterminées de notre logiciel.

Nous avons fais le choix d'utiliser comme environnement de travail l'IDE eclipse.
Pour la raison que nous connaissons tous très bien cette environnement, ce qui nous permet d'avoir tous le même environnement de développement.

Également, cette IDE permet la gestion d'un projet maven ce qui nous sera parfaitement adapté.

Voici les 4 contraintes que nous avons déterminées :

. L'interface graphique.
. La communication vers la base de données.
. La communication entre les machines.
. La sécurité.


== Diagrammes de classes

== Server

include::classDiagramServer.adoc[]


== Client

include::classDiagramClient.adoc[]
